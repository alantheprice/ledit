{
  "id": "codebase_refactor_middleware",
  "name": "Codebase Refactor - Middleware Pattern",
  "description": "Refactor a web server codebase to use middleware pattern for authentication and logging",
  "category": "agentic",
  "difficulty": "hard",
  "estimated_time_minutes": 5,
  "input": {
    "prompt": "Refactor this Go web server code to use a middleware pattern for authentication and logging. The current code has auth and logging scattered throughout handlers.",
    "codebase": {
      "files": {
        "main.go": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype User struct {\n\tID   int    `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\nvar users = []User{\n\t{ID: 1, Name: \"Alice\"},\n\t{ID: 2, Name: \"Bob\"},\n}\n\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n\t// Auth check\n\tauthToken := r.Header.Get(\"Authorization\")\n\tif authToken != \"Bearer valid-token\" {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\t\n\t// Logging\n\tlog.Printf(\"[%s] %s %s - Getting users\", time.Now().Format(\"2006-01-02 15:04:05\"), r.Method, r.URL.Path)\n\t\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(users)\n}\n\nfunc createUser(w http.ResponseWriter, r *http.Request) {\n\t// Auth check\n\tauthToken := r.Header.Get(\"Authorization\")\n\tif authToken != \"Bearer valid-token\" {\n\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\t\n\t// Logging\n\tlog.Printf(\"[%s] %s %s - Creating user\", time.Now().Format(\"2006-01-02 15:04:05\"), r.Method, r.URL.Path)\n\t\n\tvar user User\n\tif err := json.NewDecoder(r.Body).Decode(&user); err != nil {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\t\n\tuser.ID = len(users) + 1\n\tusers = append(users, user)\n\t\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusCreated)\n\tjson.NewEncoder(w).Encode(user)\n}\n\nfunc getHealth(w http.ResponseWriter, r *http.Request) {\n\t// No auth needed for health check\n\t\n\t// Logging\n\tlog.Printf(\"[%s] %s %s - Health check\", time.Now().Format(\"2006-01-02 15:04:05\"), r.Method, r.URL.Path)\n\t\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(map[string]string{\"status\": \"ok\"})\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tswitch r.Method {\n\t\tcase \"GET\":\n\t\t\tgetUsers(w, r)\n\t\tcase \"POST\":\n\t\t\tcreateUser(w, r)\n\t\tdefault:\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t}\n\t})\n\t\n\thttp.HandleFunc(\"/health\", getHealth)\n\t\n\tfmt.Println(\"Server starting on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}"
      },
      "context": "This is a simple REST API server that needs refactoring to use middleware patterns for cross-cutting concerns."
    },
    "requirements": [
      "Create middleware functions for authentication and logging",
      "Refactor handlers to remove duplicated auth/logging code",
      "Maintain the same API behavior",
      "Make middleware composable and reusable",
      "Include proper error handling",
      "Add comments explaining the middleware pattern"
    ]
  },
  "expected_outputs": {
    "middleware_functions": ["authMiddleware", "loggingMiddleware"],
    "refactored_handlers": ["getUsers", "createUser", "getHealth"], 
    "middleware_composition": true,
    "maintains_behavior": true,
    "code_organization": "improved"
  },
  "evaluation": {
    "agentic_capabilities": [
      "code_analysis",
      "pattern_identification", 
      "refactoring_strategy",
      "code_generation",
      "testing_consideration"
    ],
    "technical_requirements": [
      "middleware_functions_created",
      "duplicate_code_removed",
      "proper_middleware_chaining",
      "error_handling_preserved",
      "api_behavior_maintained"
    ],
    "code_quality": [
      "proper_go_syntax",
      "follows_middleware_pattern",
      "good_separation_of_concerns",
      "reusable_components",
      "clear_documentation"
    ]
  },
  "scoring": {
    "max_points": 100,
    "agentic_reasoning": 30,
    "technical_correctness": 40, 
    "code_quality": 20,
    "completeness": 10
  },
  "success_criteria": {
    "must_have": [
      "Creates middleware functions",
      "Removes duplicate auth/logging code",
      "Maintains API functionality",
      "Valid Go syntax"
    ],
    "should_have": [
      "Composable middleware design",
      "Good error handling",
      "Clear documentation",
      "Follows Go conventions"
    ],
    "nice_to_have": [
      "Additional middleware suggestions",
      "Testing recommendations",
      "Performance considerations"
    ]
  }
}