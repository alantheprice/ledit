{
  "id": "feature_implementation_rate_limiter",
  "name": "Feature Implementation - Rate Limiter",
  "description": "Implement a rate limiting feature for an existing API service",
  "category": "agentic", 
  "difficulty": "hard",
  "estimated_time_minutes": 6,
  "input": {
    "prompt": "Add a rate limiting feature to this API service. Implement per-user rate limiting with configurable limits and a sliding window algorithm. The service should return appropriate HTTP status codes and headers.",
    "codebase": {
      "files": {
        "server.go": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n)\n\ntype APIResponse struct {\n\tMessage   string      `json:\"message\"`\n\tData      interface{} `json:\"data,omitempty\"`\n\tTimestamp time.Time   `json:\"timestamp\"`\n}\n\ntype User struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tEmail    string `json:\"email\"`\n}\n\nvar users = []User{\n\t{ID: 1, Username: \"alice\", Email: \"alice@example.com\"},\n\t{ID: 2, Username: \"bob\", Email: \"bob@example.com\"},\n\t{ID: 3, Username: \"charlie\", Email: \"charlie@example.com\"},\n}\n\nfunc getUserByID(id int) *User {\n\tfor _, user := range users {\n\t\tif user.ID == id {\n\t\t\treturn &user\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc handleGetUser(w http.ResponseWriter, r *http.Request) {\n\tuserIDStr := r.URL.Query().Get(\"id\")\n\tif userIDStr == \"\" {\n\t\thttp.Error(w, \"Missing user ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\t\n\tuserID, err := strconv.Atoi(userIDStr)\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid user ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\t\n\tuser := getUserByID(userID)\n\tif user == nil {\n\t\thttp.Error(w, \"User not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\t\n\tresponse := APIResponse{\n\t\tMessage:   \"User retrieved successfully\",\n\t\tData:      user,\n\t\tTimestamp: time.Now(),\n\t}\n\t\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n}\n\nfunc handleListUsers(w http.ResponseWriter, r *http.Request) {\n\tresponse := APIResponse{\n\t\tMessage:   \"Users retrieved successfully\",\n\t\tData:      users,\n\t\tTimestamp: time.Now(),\n\t}\n\t\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(response)\n}\n\nfunc handleCreateUser(w http.ResponseWriter, r *http.Request) {\n\tvar newUser User\n\tif err := json.NewDecoder(r.Body).Decode(&newUser); err != nil {\n\t\thttp.Error(w, \"Invalid JSON\", http.StatusBadRequest)\n\t\treturn\n\t}\n\t\n\tnewUser.ID = len(users) + 1\n\tusers = append(users, newUser)\n\t\n\tresponse := APIResponse{\n\t\tMessage:   \"User created successfully\",\n\t\tData:      newUser,\n\t\tTimestamp: time.Now(),\n\t}\n\t\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusCreated)\n\tjson.NewEncoder(w).Encode(response)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\tswitch r.Method {\n\t\tcase \"GET\":\n\t\t\thandleGetUser(w, r)\n\t\tcase \"POST\":\n\t\t\thandleCreateUser(w, r)\n\t\tdefault:\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t}\n\t})\n\t\n\thttp.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method == \"GET\" {\n\t\t\thandleListUsers(w, r)\n\t\t} else {\n\t\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\t}\n\t})\n\t\n\tfmt.Println(\"Server starting on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}",
        "config.go": "package main\n\n// Configuration would go here\ntype Config struct {\n\tPort string\n\t// Add rate limiting config here\n}",
        "README.md": "# User API Service\\n\\nA simple REST API for user management.\\n\\n## Endpoints\\n\\n- GET /user?id=<id> - Get user by ID\\n- GET /users - List all users  \\n- POST /user - Create new user\\n\\n## TODO\\n\\n- Add rate limiting\\n- Add authentication\\n- Add database integration"
      },
      "context": "This is a simple REST API that needs rate limiting to prevent abuse. The service currently has no protection against excessive requests."
    },
    "requirements": [
      "Implement per-user rate limiting (identify users by IP address or API key)",
      "Use sliding window algorithm for accurate rate limiting",
      "Make rate limits configurable (requests per minute)",
      "Return proper HTTP status codes (429 Too Many Requests)",
      "Include rate limit headers (X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset)",
      "Add middleware pattern for clean integration",
      "Handle edge cases and cleanup expired entries",
      "Include configuration for different endpoints"
    ]
  },
  "expected_outputs": {
    "rate_limiter_implementation": true,
    "sliding_window_algorithm": true,
    "per_user_tracking": true,
    "configurable_limits": true,
    "proper_http_responses": true,
    "rate_limit_headers": true,
    "middleware_pattern": true
  },
  "evaluation": {
    "agentic_capabilities": [
      "requirements_analysis",
      "architecture_design",
      "algorithm_selection",
      "integration_strategy",
      "edge_case_handling"
    ],
    "technical_requirements": [
      "sliding_window_implemented",
      "per_user_identification",
      "configurable_parameters",
      "proper_http_status_codes",
      "rate_limit_headers_included",
      "memory_management",
      "thread_safety"
    ],
    "implementation_quality": [
      "clean_middleware_pattern",
      "separation_of_concerns",
      "error_handling",
      "configuration_management",
      "performance_considerations"
    ]
  },
  "scoring": {
    "max_points": 100,
    "architecture_design": 25,
    "algorithm_implementation": 30,
    "integration_quality": 25,
    "completeness": 20
  },
  "success_criteria": {
    "must_have": [
      "Implements rate limiting functionality",
      "Returns 429 status when limit exceeded",
      "Tracks requests per user/IP",
      "Configurable rate limits"
    ],
    "should_have": [
      "Uses sliding window algorithm",
      "Includes proper HTTP headers",
      "Implements as middleware",
      "Handles memory cleanup",
      "Thread-safe implementation"
    ],
    "nice_to_have": [
      "Multiple rate limit tiers",
      "Configurable time windows",
      "Metrics and monitoring",
      "Whitelist/blacklist support",
      "Redis backend option"
    ]
  }
}