{
  "id": "implement_workspace_caching_real", 
  "name": "Real Codebase - Implement Workspace Caching",
  "description": "Add intelligent caching to ledit's workspace analysis to improve performance on large codebases",
  "category": "real_world",
  "difficulty": "expert", 
  "estimated_time_minutes": 18,
  "git_setup": {
    "base_branch": "feat/merge-in-coder-agent",
    "test_branch": "test/agentic-workspace-cache", 
    "temp_directory": "/tmp/ledit_cache_test_{timestamp}",
    "repository_url": "local",
    "introduced_changes": {
      "files_to_modify": [
        "pkg/workspace/workspace_analyzer.go",
        "pkg/workspace/workspace_context.go",
        "pkg/workspace/workspace_manager.go"
      ],
      "issues_to_introduce": [
        "Add artificial performance bottlenecks with repeated file system scans",
        "Remove any existing caching mechanisms", 
        "Add memory usage that grows unbounded",
        "Force full workspace re-analysis on every request"
      ]
    }
  },
  "input": {
    "prompt": "The workspace analysis is currently too slow for large codebases, causing poor user experience. Please implement an intelligent caching system that:\n\n1. **Cache Strategy**: Design a multi-layer caching approach (in-memory + disk-based)\n2. **Cache Invalidation**: Implement smart invalidation based on file modifications, git changes, and time-based expiry\n3. **Performance Optimization**: Reduce redundant file system operations and expensive analysis computations\n4. **Memory Management**: Prevent unbounded memory growth with LRU eviction and configurable limits\n5. **Incremental Updates**: Support partial cache updates when only some files change\n6. **Persistence**: Cache results should survive process restarts where appropriate\n\nThe solution should dramatically improve performance for repeated workspace operations while maintaining accuracy of analysis results.",
    "working_directory": "{temp_directory}",
    "context": "You are working on the ledit codebase. The workspace analyzer scans files, analyzes code structure, and builds context for the AI agent. This is currently a bottleneck for large projects with thousands of files."
  },
  "expected_outputs": {
    "caching_strategy_designed": true,
    "cache_invalidation_implemented": true,
    "performance_optimizations": true,
    "memory_management": true,
    "incremental_updates": true,
    "persistence_layer": true
  },
  "evaluation": {
    "agentic_capabilities": [
      "performance_analysis",
      "caching_architecture_design", 
      "scalability_optimization",
      "system_design_thinking",
      "trade_off_analysis"
    ],
    "technical_requirements": [
      "implements_multi_layer_caching",
      "handles_cache_invalidation_correctly",
      "provides_significant_performance_improvement",
      "manages_memory_efficiently",
      "supports_incremental_updates",
      "maintains_analysis_accuracy"
    ],
    "implementation_quality": [
      "clean_cache_abstractions",
      "configurable_cache_parameters",
      "comprehensive_testing",
      "monitoring_and_metrics",
      "error_handling_and_recovery"
    ]
  },
  "scoring": {
    "max_points": 100,
    "architecture_design": 25,
    "performance_improvement": 30,
    "cache_correctness": 25,
    "implementation_quality": 20
  },
  "success_criteria": {
    "must_have": [
      "Implements functional caching system",
      "Shows measurable performance improvement",
      "Maintains workspace analysis accuracy",
      "Code compiles and runs correctly"
    ],
    "should_have": [
      "Handles cache invalidation properly",
      "Implements memory management",
      "Supports configurable cache settings",
      "Includes performance benchmarks",
      "Provides cache hit/miss metrics"
    ],
    "nice_to_have": [
      "Implements disk-based persistence",
      "Supports distributed caching",
      "Provides cache warming strategies",
      "Includes monitoring dashboards",
      "Handles concurrent cache access elegantly"
    ]
  },
  "validation": {
    "compilation_check": "go build ./...",
    "unit_tests": "go test ./pkg/workspace/... -timeout 60s",
    "integration_tests": "go test ./pkg/workspace/... -tags=integration -timeout 120s", 
    "performance_benchmark": "go test -bench=. ./pkg/workspace/... -benchtime=10s",
    "memory_usage_check": "go test -memprofile=mem.prof ./pkg/workspace/... && go tool pprof mem.prof"
  }
}