
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>layered: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/alantheprice/ledit/pkg/config/layered/loader.go (70.9%)</option>
				
				<option value="file1">github.com/alantheprice/ledit/pkg/config/layered/sources.go (50.0%)</option>
				
				<option value="file2">github.com/alantheprice/ledit/pkg/config/layered/validator.go (60.2%)</option>
				
				<option value="file3">github.com/alantheprice/ledit/pkg/config/layered/watcher.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package layered

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/alantheprice/ledit/pkg/config"
        "github.com/alantheprice/ledit/pkg/interfaces/types"
)

// ConfigurationLayer represents a single layer of configuration
type ConfigurationLayer struct {
        Name     string `json:"name"`
        Priority int    `json:"priority"` // Higher priority overrides lower
        Source   string `json:"source"`   // file path, environment, etc.
        Data     *config.Config
}

// LayeredConfigLoader loads and manages multiple configuration layers
type LayeredConfigLoader struct {
        layers        []ConfigurationLayer
        mergedConfig  *config.Config
        watchHandlers []func()
}

// ConfigSource defines where configuration can be loaded from
type ConfigSource interface {
        Load(ctx context.Context) (*config.Config, error)
        Watch(ctx context.Context, callback func()) error
        GetName() string
        GetPriority() int
}

// NewLayeredConfigLoader creates a new layered configuration loader
func NewLayeredConfigLoader() *LayeredConfigLoader <span class="cov8" title="1">{
        return &amp;LayeredConfigLoader{
                layers:        []ConfigurationLayer{},
                watchHandlers: []func(){},
        }
}</span>

// AddConfigSource adds a configuration source to the loader
func (l *LayeredConfigLoader) AddConfigSource(source ConfigSource) error <span class="cov8" title="1">{
        ctx := context.Background()
        cfg, err := source.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                // Non-fatal - configuration source might not exist yet
                cfg = config.DefaultConfig()
        }</span>

        <span class="cov8" title="1">layer := ConfigurationLayer{
                Name:     source.GetName(),
                Priority: source.GetPriority(),
                Source:   source.GetName(),
                Data:     cfg,
        }

        l.layers = append(l.layers, layer)
        l.sortLayersByPriority()
        l.mergeConfigurations()

        return nil</span>
}

// GetMergedConfig returns the final merged configuration
func (l *LayeredConfigLoader) GetMergedConfig() *config.Config <span class="cov8" title="1">{
        if l.mergedConfig == nil </span><span class="cov0" title="0">{
                l.mergeConfigurations()
        }</span>
        <span class="cov8" title="1">return l.mergedConfig</span>
}

// ReloadAll reloads all configuration sources
func (l *LayeredConfigLoader) ReloadAll(ctx context.Context) error <span class="cov0" title="0">{
        // For now, create a simplified reload - would integrate with actual sources
        l.mergeConfigurations()
        return nil
}</span>

// sortLayersByPriority sorts layers by priority (highest first)
func (l *LayeredConfigLoader) sortLayersByPriority() <span class="cov8" title="1">{
        // Simple bubble sort by priority
        for i := 0; i &lt; len(l.layers)-1; i++ </span><span class="cov8" title="1">{
                for j := 0; j &lt; len(l.layers)-i-1; j++ </span><span class="cov8" title="1">{
                        if l.layers[j].Priority &lt; l.layers[j+1].Priority </span><span class="cov8" title="1">{
                                l.layers[j], l.layers[j+1] = l.layers[j+1], l.layers[j]
                        }</span>
                }
        }
}

// mergeConfigurations merges all layers into a single configuration
func (l *LayeredConfigLoader) mergeConfigurations() <span class="cov8" title="1">{
        if len(l.layers) == 0 </span><span class="cov0" title="0">{
                l.mergedConfig = config.DefaultConfig()
                return
        }</span>

        // Start with the lowest priority (last in sorted array)
        <span class="cov8" title="1">base := l.layers[len(l.layers)-1].Data
        if base == nil </span><span class="cov0" title="0">{
                base = config.DefaultConfig()
        }</span>

        // Create a copy to avoid modifying the original
        <span class="cov8" title="1">merged := l.copyConfig(base)

        // Apply higher priority layers on top
        for i := len(l.layers) - 2; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                layer := l.layers[i]
                if layer.Data != nil </span><span class="cov8" title="1">{
                        merged = l.mergeConfig(merged, layer.Data)
                }</span>
        }

        <span class="cov8" title="1">l.mergedConfig = merged</span>
}

// copyConfig creates a deep copy of a config (simplified)
func (l *LayeredConfigLoader) copyConfig(src *config.Config) *config.Config <span class="cov8" title="1">{
        // For now, use JSON marshal/unmarshal for deep copy
        data, err := json.Marshal(src)
        if err != nil </span><span class="cov0" title="0">{
                return config.DefaultConfig()
        }</span>

        <span class="cov8" title="1">var dst config.Config
        if err := json.Unmarshal(data, &amp;dst); err != nil </span><span class="cov0" title="0">{
                return config.DefaultConfig()
        }</span>

        // Copy non-JSON fields manually
        <span class="cov8" title="1">dst.SkipPrompt = src.SkipPrompt

        return &amp;dst</span>
}

// mergeConfig merges overlay config into base config
func (l *LayeredConfigLoader) mergeConfig(base, overlay *config.Config) *config.Config <span class="cov8" title="1">{
        result := l.copyConfig(base)

        // Merge LLM configuration
        if overlay.LLM != nil </span><span class="cov8" title="1">{
                if result.LLM == nil </span><span class="cov0" title="0">{
                        result.LLM = overlay.LLM
                }</span> else<span class="cov8" title="1"> {
                        result.LLM = l.mergeLLMConfig(result.LLM, overlay.LLM)
                }</span>
        }

        // Merge UI configuration
        <span class="cov8" title="1">if overlay.UI != nil </span><span class="cov8" title="1">{
                if result.UI == nil </span><span class="cov0" title="0">{
                        result.UI = overlay.UI
                }</span> else<span class="cov8" title="1"> {
                        result.UI = l.mergeUIConfig(result.UI, overlay.UI)
                }</span>
        }

        // Merge Agent configuration
        <span class="cov8" title="1">if overlay.Agent != nil </span><span class="cov8" title="1">{
                if result.Agent == nil </span><span class="cov0" title="0">{
                        result.Agent = overlay.Agent
                }</span> else<span class="cov8" title="1"> {
                        result.Agent = l.mergeAgentConfig(result.Agent, overlay.Agent)
                }</span>
        }

        // Merge Security configuration
        <span class="cov8" title="1">if overlay.Security != nil </span><span class="cov8" title="1">{
                if result.Security == nil </span><span class="cov0" title="0">{
                        result.Security = overlay.Security
                }</span> else<span class="cov8" title="1"> {
                        result.Security = l.mergeSecurityConfig(result.Security, overlay.Security)
                }</span>
        }

        // Merge Performance configuration
        <span class="cov8" title="1">if overlay.Performance != nil </span><span class="cov8" title="1">{
                if result.Performance == nil </span><span class="cov0" title="0">{
                        result.Performance = overlay.Performance
                }</span> else<span class="cov8" title="1"> {
                        result.Performance = l.mergePerformanceConfig(result.Performance, overlay.Performance)
                }</span>
        }

        // Override simple fields if they're set in overlay
        <span class="cov8" title="1">if overlay.SkipPrompt </span><span class="cov0" title="0">{
                result.SkipPrompt = overlay.SkipPrompt
        }</span>

        <span class="cov8" title="1">return result</span>
}

// mergeLLMConfig merges LLM configurations
func (l *LayeredConfigLoader) mergeLLMConfig(base, overlay *config.LLMConfig) *config.LLMConfig <span class="cov8" title="1">{
        result := *base // Shallow copy

        if overlay.EditingModel != "" </span><span class="cov8" title="1">{
                result.EditingModel = overlay.EditingModel
        }</span>
        <span class="cov8" title="1">if overlay.SummaryModel != "" </span><span class="cov8" title="1">{
                result.SummaryModel = overlay.SummaryModel
        }</span>
        <span class="cov8" title="1">if overlay.OrchestrationModel != "" </span><span class="cov8" title="1">{
                result.OrchestrationModel = overlay.OrchestrationModel
        }</span>
        <span class="cov8" title="1">if overlay.WorkspaceModel != "" </span><span class="cov8" title="1">{
                result.WorkspaceModel = overlay.WorkspaceModel
        }</span>
        <span class="cov8" title="1">if overlay.Temperature != 0 </span><span class="cov8" title="1">{
                result.Temperature = overlay.Temperature
        }</span>
        <span class="cov8" title="1">if overlay.MaxTokens != 0 </span><span class="cov8" title="1">{
                result.MaxTokens = overlay.MaxTokens
        }</span>

        <span class="cov8" title="1">return &amp;result</span>
}

// mergeUIConfig merges UI configurations
func (l *LayeredConfigLoader) mergeUIConfig(base, overlay *config.UIConfig) *config.UIConfig <span class="cov8" title="1">{
        result := *base // Shallow copy

        // Merge the actual fields that exist in UIConfig
        if overlay.JsonLogs != base.JsonLogs </span><span class="cov0" title="0">{
                result.JsonLogs = overlay.JsonLogs
        }</span>
        <span class="cov8" title="1">if overlay.HealthChecks != base.HealthChecks </span><span class="cov0" title="0">{
                result.HealthChecks = overlay.HealthChecks
        }</span>
        <span class="cov8" title="1">if overlay.PreapplyReview != base.PreapplyReview </span><span class="cov0" title="0">{
                result.PreapplyReview = overlay.PreapplyReview
        }</span>
        <span class="cov8" title="1">if overlay.TelemetryEnabled != base.TelemetryEnabled </span><span class="cov0" title="0">{
                result.TelemetryEnabled = overlay.TelemetryEnabled
        }</span>
        <span class="cov8" title="1">if overlay.TelemetryFile != "" &amp;&amp; overlay.TelemetryFile != base.TelemetryFile </span><span class="cov0" title="0">{
                result.TelemetryFile = overlay.TelemetryFile
        }</span>
        <span class="cov8" title="1">if overlay.TrackWithGit != base.TrackWithGit </span><span class="cov0" title="0">{
                result.TrackWithGit = overlay.TrackWithGit
        }</span>
        <span class="cov8" title="1">if overlay.StagedEdits != base.StagedEdits </span><span class="cov0" title="0">{
                result.StagedEdits = overlay.StagedEdits
        }</span>

        <span class="cov8" title="1">return &amp;result</span>
}

// mergeAgentConfig merges Agent configurations
func (l *LayeredConfigLoader) mergeAgentConfig(base, overlay *config.AgentConfig) *config.AgentConfig <span class="cov8" title="1">{
        result := *base // Shallow copy

        if overlay.OrchestrationMaxAttempts != 0 </span><span class="cov8" title="1">{
                result.OrchestrationMaxAttempts = overlay.OrchestrationMaxAttempts
        }</span>
        <span class="cov8" title="1">if overlay.PolicyVariant != "" </span><span class="cov8" title="1">{
                result.PolicyVariant = overlay.PolicyVariant
        }</span>
        <span class="cov8" title="1">if overlay.AutoGenerateTests != base.AutoGenerateTests </span><span class="cov0" title="0">{
                result.AutoGenerateTests = overlay.AutoGenerateTests
        }</span>
        <span class="cov8" title="1">if overlay.DryRun != base.DryRun </span><span class="cov0" title="0">{
                result.DryRun = overlay.DryRun
        }</span>
        <span class="cov8" title="1">if overlay.CodeToolsEnabled != base.CodeToolsEnabled </span><span class="cov0" title="0">{
                result.CodeToolsEnabled = overlay.CodeToolsEnabled
        }</span>

        <span class="cov8" title="1">return &amp;result</span>
}

// mergeSecurityConfig merges Security configurations
func (l *LayeredConfigLoader) mergeSecurityConfig(base, overlay *config.SecurityConfig) *config.SecurityConfig <span class="cov8" title="1">{
        result := *base // Shallow copy

        if overlay.EnableSecurityChecks != base.EnableSecurityChecks </span><span class="cov0" title="0">{
                result.EnableSecurityChecks = overlay.EnableSecurityChecks
        }</span>
        <span class="cov8" title="1">if len(overlay.ShellAllowlist) &gt; 0 </span><span class="cov8" title="1">{
                result.ShellAllowlist = overlay.ShellAllowlist
        }</span>
        <span class="cov8" title="1">if len(overlay.AllowedCommands) &gt; 0 </span><span class="cov0" title="0">{
                result.AllowedCommands = overlay.AllowedCommands
        }</span>
        <span class="cov8" title="1">if len(overlay.BlockedCommands) &gt; 0 </span><span class="cov8" title="1">{
                result.BlockedCommands = overlay.BlockedCommands
        }</span>
        <span class="cov8" title="1">if len(overlay.AllowedPaths) &gt; 0 </span><span class="cov0" title="0">{
                result.AllowedPaths = overlay.AllowedPaths
        }</span>
        <span class="cov8" title="1">if len(overlay.BlockedPaths) &gt; 0 </span><span class="cov8" title="1">{
                result.BlockedPaths = overlay.BlockedPaths
        }</span>
        <span class="cov8" title="1">if overlay.RequireApproval != base.RequireApproval </span><span class="cov0" title="0">{
                result.RequireApproval = overlay.RequireApproval
        }</span>

        <span class="cov8" title="1">return &amp;result</span>
}

// mergePerformanceConfig merges Performance configurations
func (l *LayeredConfigLoader) mergePerformanceConfig(base, overlay *config.PerformanceConfig) *config.PerformanceConfig <span class="cov8" title="1">{
        result := *base // Shallow copy

        if overlay.MaxConcurrentRequests != 0 </span><span class="cov8" title="1">{
                result.MaxConcurrentRequests = overlay.MaxConcurrentRequests
        }</span>
        <span class="cov8" title="1">if overlay.RequestDelayMs != 0 </span><span class="cov8" title="1">{
                result.RequestDelayMs = overlay.RequestDelayMs
        }</span>
        <span class="cov8" title="1">if overlay.EmbeddingBatchSize != 0 </span><span class="cov8" title="1">{
                result.EmbeddingBatchSize = overlay.EmbeddingBatchSize
        }</span>

        <span class="cov8" title="1">return &amp;result</span>
}

// LayeredConfigProvider adapts LayeredConfigLoader to interfaces.ConfigProvider
type LayeredConfigProvider struct {
        loader *LayeredConfigLoader
}

// NewLayeredConfigProvider creates a new layered configuration provider
func NewLayeredConfigProvider() *LayeredConfigProvider <span class="cov8" title="1">{
        return &amp;LayeredConfigProvider{
                loader: NewLayeredConfigLoader(),
        }
}</span>

// AddSource adds a configuration source
func (p *LayeredConfigProvider) AddSource(source ConfigSource) error <span class="cov8" title="1">{
        return p.loader.AddConfigSource(source)
}</span>

// GetMergedConfig returns the merged configuration from all sources
func (p *LayeredConfigProvider) GetMergedConfig() *config.Config <span class="cov8" title="1">{
        return p.loader.GetMergedConfig()
}</span>

// GetProviderConfig implements interfaces.ConfigProvider
func (p *LayeredConfigProvider) GetProviderConfig(providerName string) (*types.ProviderConfig, error) <span class="cov0" title="0">{
        merged := p.loader.GetMergedConfig()
        llmConfig := merged.GetLLMConfig()

        config := &amp;types.ProviderConfig{
                Name:        providerName,
                Model:       llmConfig.GetPrimaryModel(),
                Temperature: llmConfig.Temperature,
                MaxTokens:   llmConfig.MaxTokens,
                Timeout:     llmConfig.DefaultTimeoutSecs,
                Enabled:     true,
        }

        // Set provider-specific configurations
        switch providerName </span>{
        case "openai":<span class="cov0" title="0">
                config.BaseURL = "https://api.openai.com/v1"
                config.APIKey = "placeholder-key"</span> // Would get from API keys file
        case "gemini":<span class="cov0" title="0">
                config.BaseURL = "https://generativelanguage.googleapis.com"
                config.APIKey = "placeholder-key"</span>
        case "ollama":<span class="cov0" title="0">
                config.BaseURL = llmConfig.OllamaServerURL</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown provider: %s", providerName)</span>
        }

        <span class="cov0" title="0">return config, nil</span>
}

// GetAgentConfig implements interfaces.ConfigProvider
func (p *LayeredConfigProvider) GetAgentConfig() *types.AgentConfig <span class="cov8" title="1">{
        merged := p.loader.GetMergedConfig()
        agentConfig := merged.GetAgentConfig()

        return &amp;types.AgentConfig{
                MaxRetries:           agentConfig.OrchestrationMaxAttempts,
                RetryDelay:           5,
                MaxContextRequests:   10,
                EnableValidation:     !merged.SkipPrompt,
                EnableCodeReview:     !merged.SkipPrompt,
                ValidationTimeout:    30,
                DefaultStrategy:      "quick",
                CostThreshold:        0.1,
        }
}</span>

// GetEditorConfig implements interfaces.ConfigProvider
func (p *LayeredConfigProvider) GetEditorConfig() *types.EditorConfig <span class="cov0" title="0">{
        return &amp;types.EditorConfig{
                BackupEnabled:    true,
                DiffStyle:        "unified",
                AutoFormat:       true,
                PreferredLanguage: "go",
                IgnorePatterns:   []string{"*.test", "*.tmp"},
                MaxFileSize:      1024 * 1024,
        }
}</span>

// GetSecurityConfig implements interfaces.ConfigProvider
func (p *LayeredConfigProvider) GetSecurityConfig() *types.SecurityConfig <span class="cov8" title="1">{
        merged := p.loader.GetMergedConfig()
        securityConfig := merged.GetSecurityConfig()

        return &amp;types.SecurityConfig{
                EnableCredentialScanning: securityConfig.EnableSecurityChecks,
                BlockedPatterns:         securityConfig.BlockedCommands, // Map blocked commands to blocked patterns
                AllowedCommands:         securityConfig.AllowedCommands,
                RequireConfirmation:     !merged.SkipPrompt,
        }
}</span>

// GetUIConfig implements interfaces.ConfigProvider
func (p *LayeredConfigProvider) GetUIConfig() *types.UIConfig <span class="cov8" title="1">{
        merged := p.loader.GetMergedConfig()
        uiConfig := merged.GetUIConfig()

        return &amp;types.UIConfig{
                SkipPrompts:      merged.SkipPrompt,
                ColorOutput:      true, // Default to true
                VerboseLogging:   uiConfig.JsonLogs, // Map JsonLogs to VerboseLogging
                ProgressBars:     uiConfig.ShouldDisplayProgress(),
                OutputFormat:     "text",
        }
}</span>

// SetConfig implements interfaces.ConfigProvider
func (p *LayeredConfigProvider) SetConfig(key string, value interface{}) error <span class="cov0" title="0">{
        // Updates would be applied to the highest priority writable layer
        return fmt.Errorf("configuration updates not implemented in layered provider")
}</span>

// SaveConfig implements interfaces.ConfigProvider
func (p *LayeredConfigProvider) SaveConfig() error <span class="cov0" title="0">{
        return fmt.Errorf("configuration saving not implemented in layered provider")
}</span>

// ReloadConfig implements interfaces.ConfigProvider
func (p *LayeredConfigProvider) ReloadConfig() error <span class="cov0" title="0">{
        return p.loader.ReloadAll(context.Background())
}</span>

// WatchConfig implements interfaces.ConfigProvider
func (p *LayeredConfigProvider) WatchConfig(callback func()) error <span class="cov0" title="0">{
        p.loader.watchHandlers = append(p.loader.watchHandlers, callback)
        return nil
}</pre>
		
		<pre class="file" id="file1" style="display: none">package layered

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/alantheprice/ledit/pkg/config"
)

// FileConfigSource loads configuration from a JSON file
type FileConfigSource struct {
        FilePath string
        Name     string
        Priority int
        Required bool // If true, error if file doesn't exist
}

// NewFileConfigSource creates a new file-based configuration source
func NewFileConfigSource(filePath, name string, priority int, required bool) *FileConfigSource <span class="cov8" title="1">{
        return &amp;FileConfigSource{
                FilePath: filePath,
                Name:     name,
                Priority: priority,
                Required: required,
        }
}</span>

// Load implements ConfigSource.Load
func (f *FileConfigSource) Load(ctx context.Context) (*config.Config, error) <span class="cov8" title="1">{
        if _, err := os.Stat(f.FilePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                if f.Required </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("required config file not found: %s", f.FilePath)
                }</span>
                <span class="cov8" title="1">return config.DefaultConfig(), nil</span>
        }

        <span class="cov8" title="1">data, err := os.ReadFile(f.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file %s: %w", f.FilePath, err)
        }</span>

        <span class="cov8" title="1">var cfg config.Config
        if err := json.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file %s: %w", f.FilePath, err)
        }</span>

        // Ensure sub-configs are initialized
        <span class="cov8" title="1">if cfg.LLM == nil </span><span class="cov8" title="1">{
                cfg.LLM = config.DefaultLLMConfig()
        }</span>
        <span class="cov8" title="1">if cfg.UI == nil </span><span class="cov8" title="1">{
                cfg.UI = config.DefaultUIConfig()
        }</span>
        <span class="cov8" title="1">if cfg.Agent == nil </span><span class="cov8" title="1">{
                cfg.Agent = config.DefaultAgentConfig()
        }</span>
        <span class="cov8" title="1">if cfg.Security == nil </span><span class="cov8" title="1">{
                cfg.Security = config.DefaultSecurityConfig()
        }</span>
        <span class="cov8" title="1">if cfg.Performance == nil </span><span class="cov8" title="1">{
                cfg.Performance = config.DefaultPerformanceConfig()
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// Watch implements ConfigSource.Watch
func (f *FileConfigSource) Watch(ctx context.Context, callback func()) error <span class="cov0" title="0">{
        // For now, return not implemented - would integrate with file system watcher
        return fmt.Errorf("file watching not implemented for config source: %s", f.Name)
}</span>

// GetName implements ConfigSource.GetName
func (f *FileConfigSource) GetName() string <span class="cov8" title="1">{
        return f.Name
}</span>

// GetPriority implements ConfigSource.GetPriority
func (f *FileConfigSource) GetPriority() int <span class="cov8" title="1">{
        return f.Priority
}</span>

// EnvironmentConfigSource loads configuration from environment variables
type EnvironmentConfigSource struct {
        Prefix   string // Environment variable prefix (e.g., "LEDIT_")
        Name     string
        Priority int
}

// NewEnvironmentConfigSource creates a new environment-based configuration source
func NewEnvironmentConfigSource(prefix, name string, priority int) *EnvironmentConfigSource <span class="cov8" title="1">{
        return &amp;EnvironmentConfigSource{
                Prefix:   prefix,
                Name:     name,
                Priority: priority,
        }
}</span>

// Load implements ConfigSource.Load
func (e *EnvironmentConfigSource) Load(ctx context.Context) (*config.Config, error) <span class="cov8" title="1">{
        cfg := config.DefaultConfig()

        // Map environment variables to configuration
        envVars := e.getEnvironmentVariables()
        
        for key, value := range envVars </span><span class="cov8" title="1">{
                switch strings.ToLower(key) </span>{
                case "editing_model":<span class="cov0" title="0">
                        if cfg.LLM == nil </span><span class="cov0" title="0">{
                                cfg.LLM = config.DefaultLLMConfig()
                        }</span>
                        <span class="cov0" title="0">cfg.LLM.EditingModel = value</span>
                case "summary_model":<span class="cov0" title="0">
                        if cfg.LLM == nil </span><span class="cov0" title="0">{
                                cfg.LLM = config.DefaultLLMConfig()
                        }</span>
                        <span class="cov0" title="0">cfg.LLM.SummaryModel = value</span>
                case "orchestration_model":<span class="cov0" title="0">
                        if cfg.LLM == nil </span><span class="cov0" title="0">{
                                cfg.LLM = config.DefaultLLMConfig()
                        }</span>
                        <span class="cov0" title="0">cfg.LLM.OrchestrationModel = value</span>
                case "temperature":<span class="cov8" title="1">
                        if temp, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov8" title="1">{
                                if cfg.LLM == nil </span><span class="cov0" title="0">{
                                        cfg.LLM = config.DefaultLLMConfig()
                                }</span>
                                <span class="cov8" title="1">cfg.LLM.Temperature = temp</span>
                        }
                case "max_tokens":<span class="cov0" title="0">
                        if tokens, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                if cfg.LLM == nil </span><span class="cov0" title="0">{
                                        cfg.LLM = config.DefaultLLMConfig()
                                }</span>
                                <span class="cov0" title="0">cfg.LLM.MaxTokens = tokens</span>
                        }
                case "skip_prompts":<span class="cov8" title="1">
                        if skip, err := strconv.ParseBool(value); err == nil </span><span class="cov8" title="1">{
                                cfg.SkipPrompt = skip
                        }</span>
                case "verbose_logging":<span class="cov0" title="0">
                        if verbose, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                                if cfg.UI == nil </span><span class="cov0" title="0">{
                                        cfg.UI = config.DefaultUIConfig()
                                }</span>
                                <span class="cov0" title="0">cfg.UI.JsonLogs = verbose</span>
                        }
                case "color_output":<span class="cov0" title="0"></span>
                        // Color output is handled at display level, not stored in config
                        // Can be ignored for now
                case "orchestration_max_attempts":<span class="cov0" title="0">
                        if attempts, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                if cfg.Agent == nil </span><span class="cov0" title="0">{
                                        cfg.Agent = config.DefaultAgentConfig()
                                }</span>
                                <span class="cov0" title="0">cfg.Agent.OrchestrationMaxAttempts = attempts</span>
                        }
                case "dry_run":<span class="cov0" title="0">
                        if dryRun, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                                if cfg.Agent == nil </span><span class="cov0" title="0">{
                                        cfg.Agent = config.DefaultAgentConfig()
                                }</span>
                                <span class="cov0" title="0">cfg.Agent.DryRun = dryRun</span>
                        }
                case "enable_credential_scanning":<span class="cov0" title="0">
                        if enable, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                                if cfg.Security == nil </span><span class="cov0" title="0">{
                                        cfg.Security = config.DefaultSecurityConfig()
                                }</span>
                                <span class="cov0" title="0">cfg.Security.EnableSecurityChecks = enable</span>
                        }
                case "max_concurrent_requests":<span class="cov0" title="0">
                        if maxReq, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                if cfg.Performance == nil </span><span class="cov0" title="0">{
                                        cfg.Performance = config.DefaultPerformanceConfig()
                                }</span>
                                <span class="cov0" title="0">cfg.Performance.MaxConcurrentRequests = maxReq</span>
                        }
                }
        }

        <span class="cov8" title="1">return cfg, nil</span>
}

// getEnvironmentVariables gets environment variables with the configured prefix
func (e *EnvironmentConfigSource) getEnvironmentVariables() map[string]string <span class="cov8" title="1">{
        envVars := make(map[string]string)
        
        for _, env := range os.Environ() </span><span class="cov8" title="1">{
                parts := strings.SplitN(env, "=", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov8" title="1">key, value := parts[0], parts[1]
                if strings.HasPrefix(key, e.Prefix) </span><span class="cov8" title="1">{
                        configKey := strings.TrimPrefix(key, e.Prefix)
                        envVars[strings.ToLower(configKey)] = value
                }</span>
        }
        
        <span class="cov8" title="1">return envVars</span>
}

// Watch implements ConfigSource.Watch
func (e *EnvironmentConfigSource) Watch(ctx context.Context, callback func()) error <span class="cov0" title="0">{
        // Environment variables don't change during process lifetime typically
        return nil
}</span>

// GetName implements ConfigSource.GetName
func (e *EnvironmentConfigSource) GetName() string <span class="cov8" title="1">{
        return e.Name
}</span>

// GetPriority implements ConfigSource.GetPriority
func (e *EnvironmentConfigSource) GetPriority() int <span class="cov8" title="1">{
        return e.Priority
}</span>

// DefaultsConfigSource provides default configuration values
type DefaultsConfigSource struct {
        Name     string
        Priority int
}

// NewDefaultsConfigSource creates a new defaults configuration source
func NewDefaultsConfigSource(name string, priority int) *DefaultsConfigSource <span class="cov8" title="1">{
        return &amp;DefaultsConfigSource{
                Name:     name,
                Priority: priority,
        }
}</span>

// Load implements ConfigSource.Load
func (d *DefaultsConfigSource) Load(ctx context.Context) (*config.Config, error) <span class="cov8" title="1">{
        return config.DefaultConfig(), nil
}</span>

// Watch implements ConfigSource.Watch
func (d *DefaultsConfigSource) Watch(ctx context.Context, callback func()) error <span class="cov0" title="0">{
        // Defaults don't change
        return nil
}</span>

// GetName implements ConfigSource.GetName
func (d *DefaultsConfigSource) GetName() string <span class="cov8" title="1">{
        return d.Name
}</span>

// GetPriority implements ConfigSource.GetPriority
func (d *DefaultsConfigSource) GetPriority() int <span class="cov8" title="1">{
        return d.Priority
}</span>

// ConfigurationFactory creates standard configuration setups
type ConfigurationFactory struct{}

// NewConfigurationFactory creates a new configuration factory
func NewConfigurationFactory() *ConfigurationFactory <span class="cov8" title="1">{
        return &amp;ConfigurationFactory{}
}</span>

// CreateStandardSetup creates a standard layered configuration setup
func (f *ConfigurationFactory) CreateStandardSetup() (*LayeredConfigProvider, error) <span class="cov8" title="1">{
        provider := NewLayeredConfigProvider()

        // Add configuration sources in priority order (lowest to highest)
        
        // 1. Defaults (lowest priority - 0)
        defaultsSource := NewDefaultsConfigSource("defaults", 0)
        if err := provider.AddSource(defaultsSource); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add defaults source: %w", err)
        }</span>

        // 2. Global configuration (priority 10)
        <span class="cov8" title="1">homeDir, err := os.UserHomeDir()
        if err == nil </span><span class="cov8" title="1">{
                globalConfigPath := filepath.Join(homeDir, ".ledit", "config.json")
                globalSource := NewFileConfigSource(globalConfigPath, "global", 10, false)
                if err := provider.AddSource(globalSource); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add global source: %w", err)
                }</span>
        }

        // 3. Project configuration (priority 20)
        <span class="cov8" title="1">if cwd, err := os.Getwd(); err == nil </span><span class="cov8" title="1">{
                projectConfigPath := filepath.Join(cwd, ".ledit", "config.json")
                projectSource := NewFileConfigSource(projectConfigPath, "project", 20, false)
                if err := provider.AddSource(projectSource); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add project source: %w", err)
                }</span>
        }

        // 4. Environment variables (highest priority - 30)
        <span class="cov8" title="1">envSource := NewEnvironmentConfigSource("LEDIT_", "environment", 30)
        if err := provider.AddSource(envSource); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add environment source: %w", err)
        }</span>

        <span class="cov8" title="1">return provider, nil</span>
}

// CreateDevelopmentSetup creates a development-specific configuration setup
func (f *ConfigurationFactory) CreateDevelopmentSetup() (*LayeredConfigProvider, error) <span class="cov0" title="0">{
        provider := NewLayeredConfigProvider()

        // Add development-specific sources
        defaultsSource := NewDefaultsConfigSource("defaults", 0)
        provider.AddSource(defaultsSource)

        // Development config with higher verbosity and debugging enabled
        devConfig := config.DefaultConfig()
        if devConfig.UI == nil </span><span class="cov0" title="0">{
                devConfig.UI = config.DefaultUIConfig()
        }</span>
        <span class="cov0" title="0">devConfig.UI.JsonLogs = true // Enable verbose logging via JsonLogs
        devConfig.UI.HealthChecks = true
        devConfig.SkipPrompt = false // Enable prompts in development

        // Create a memory-based source for dev config
        devSource := &amp;MemoryConfigSource{
                Name:     "development",
                Priority: 50,
                Config:   devConfig,
        }
        provider.AddSource(devSource)

        return provider, nil</span>
}

// MemoryConfigSource holds configuration in memory
type MemoryConfigSource struct {
        Name     string
        Priority int
        Config   *config.Config
}

// Load implements ConfigSource.Load
func (m *MemoryConfigSource) Load(ctx context.Context) (*config.Config, error) <span class="cov0" title="0">{
        if m.Config == nil </span><span class="cov0" title="0">{
                return config.DefaultConfig(), nil
        }</span>
        <span class="cov0" title="0">return m.Config, nil</span>
}

// Watch implements ConfigSource.Watch
func (m *MemoryConfigSource) Watch(ctx context.Context, callback func()) error <span class="cov0" title="0">{
        return nil // Memory config doesn't change externally
}</span>

// GetName implements ConfigSource.GetName
func (m *MemoryConfigSource) GetName() string <span class="cov0" title="0">{
        return m.Name
}</span>

// GetPriority implements ConfigSource.GetPriority
func (m *MemoryConfigSource) GetPriority() int <span class="cov0" title="0">{
        return m.Priority
}</pre>
		
		<pre class="file" id="file2" style="display: none">package layered

import (
        "fmt"
        "strings"

        "github.com/alantheprice/ledit/pkg/config"
        "github.com/alantheprice/ledit/pkg/interfaces/types"
)

// ValidationError represents a configuration validation error
type ValidationError struct {
        Field   string `json:"field"`
        Value   interface{} `json:"value"`
        Message string `json:"message"`
        Code    string `json:"code"`
}

// Error implements the error interface
func (e ValidationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("validation error for field '%s': %s", e.Field, e.Message)
}</span>

// ValidationResult contains the results of configuration validation
type ValidationResult struct {
        Valid    bool              `json:"valid"`
        Errors   []ValidationError `json:"errors"`
        Warnings []ValidationError `json:"warnings"`
}

// IsValid returns true if there are no validation errors
func (r *ValidationResult) IsValid() bool <span class="cov8" title="1">{
        return len(r.Errors) == 0
}</span>

// HasWarnings returns true if there are validation warnings
func (r *ValidationResult) HasWarnings() bool <span class="cov0" title="0">{
        return len(r.Warnings) &gt; 0
}</span>

// AddError adds a validation error
func (r *ValidationResult) AddError(field, message, code string, value interface{}) <span class="cov0" title="0">{
        r.Errors = append(r.Errors, ValidationError{
                Field:   field,
                Value:   value,
                Message: message,
                Code:    code,
        })
        r.Valid = false
}</span>

// AddWarning adds a validation warning
func (r *ValidationResult) AddWarning(field, message, code string, value interface{}) <span class="cov0" title="0">{
        r.Warnings = append(r.Warnings, ValidationError{
                Field:   field,
                Value:   value,
                Message: message,
                Code:    code,
        })
}</span>

// ConfigValidator validates configuration objects
type ConfigValidator struct {
        rules []ValidationRule
}

// ValidationRule defines a single validation rule
type ValidationRule interface {
        Validate(cfg *config.Config) []ValidationError
        GetName() string
        GetSeverity() ValidationSeverity
}

// ValidationSeverity represents the severity of a validation issue
type ValidationSeverity int

const (
        SeverityError   ValidationSeverity = iota // Must be fixed
        SeverityWarning                           // Should be reviewed
        SeverityInfo                             // Informational only
)

// NewConfigValidator creates a new configuration validator
func NewConfigValidator() *ConfigValidator <span class="cov8" title="1">{
        return &amp;ConfigValidator{
                rules: []ValidationRule{},
        }
}</span>

// AddRule adds a validation rule
func (v *ConfigValidator) AddRule(rule ValidationRule) <span class="cov8" title="1">{
        v.rules = append(v.rules, rule)
}</span>

// ValidateConfig validates a complete configuration
func (v *ConfigValidator) ValidateConfig(cfg *config.Config) *ValidationResult <span class="cov8" title="1">{
        result := &amp;ValidationResult{
                Valid:    true,
                Errors:   []ValidationError{},
                Warnings: []ValidationError{},
        }

        // Apply all validation rules
        for _, rule := range v.rules </span><span class="cov8" title="1">{
                errors := rule.Validate(cfg)
                for _, err := range errors </span><span class="cov8" title="1">{
                        if rule.GetSeverity() == SeverityError </span><span class="cov8" title="1">{
                                result.Errors = append(result.Errors, err)
                                result.Valid = false
                        }</span> else<span class="cov8" title="1"> if rule.GetSeverity() == SeverityWarning </span><span class="cov8" title="1">{
                                result.Warnings = append(result.Warnings, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// Standard validation rules

// LLMModelValidationRule validates LLM model configurations
type LLMModelValidationRule struct{}

func (r *LLMModelValidationRule) GetName() string <span class="cov0" title="0">{
        return "llm_model_validation"
}</span>

func (r *LLMModelValidationRule) GetSeverity() ValidationSeverity <span class="cov8" title="1">{
        return SeverityError
}</span>

func (r *LLMModelValidationRule) Validate(cfg *config.Config) []ValidationError <span class="cov8" title="1">{
        var errors []ValidationError

        if cfg.LLM == nil </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "llm",
                        Value:   nil,
                        Message: "LLM configuration is required",
                        Code:    "MISSING_LLM_CONFIG",
                })
                return errors
        }</span>

        // Validate editing model
        <span class="cov8" title="1">if cfg.LLM.EditingModel == "" </span><span class="cov8" title="1">{
                errors = append(errors, ValidationError{
                        Field:   "llm.editing_model",
                        Value:   "",
                        Message: "Editing model is required",
                        Code:    "MISSING_EDITING_MODEL",
                })
        }</span>

        // Validate temperature range
        <span class="cov8" title="1">if cfg.LLM.Temperature &lt; 0.0 || cfg.LLM.Temperature &gt; 2.0 </span><span class="cov8" title="1">{
                errors = append(errors, ValidationError{
                        Field:   "llm.temperature",
                        Value:   cfg.LLM.Temperature,
                        Message: "Temperature must be between 0.0 and 2.0",
                        Code:    "INVALID_TEMPERATURE_RANGE",
                })
        }</span>

        // Validate max tokens
        <span class="cov8" title="1">if cfg.LLM.MaxTokens &lt; 1 || cfg.LLM.MaxTokens &gt; 32768 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "llm.max_tokens",
                        Value:   cfg.LLM.MaxTokens,
                        Message: "Max tokens must be between 1 and 32768",
                        Code:    "INVALID_MAX_TOKENS_RANGE",
                })
        }</span>

        // Validate timeout
        <span class="cov8" title="1">if cfg.LLM.DefaultTimeoutSecs &lt; 10 || cfg.LLM.DefaultTimeoutSecs &gt; 600 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "llm.default_timeout_secs",
                        Value:   cfg.LLM.DefaultTimeoutSecs,
                        Message: "Timeout must be between 10 and 600 seconds",
                        Code:    "INVALID_TIMEOUT_RANGE",
                })
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// SecurityValidationRule validates security configurations
type SecurityValidationRule struct{}

func (r *SecurityValidationRule) GetName() string <span class="cov0" title="0">{
        return "security_validation"
}</span>

func (r *SecurityValidationRule) GetSeverity() ValidationSeverity <span class="cov0" title="0">{
        return SeverityWarning
}</span>

func (r *SecurityValidationRule) Validate(cfg *config.Config) []ValidationError <span class="cov8" title="1">{
        var errors []ValidationError

        if cfg.Security == nil </span><span class="cov0" title="0">{
                return errors // Security config is optional
        }</span>

        // Warn if security checks are disabled
        <span class="cov8" title="1">if !cfg.Security.EnableSecurityChecks </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "security.enable_security_checks",
                        Value:   false,
                        Message: "Security checks are disabled - this may pose security risks",
                        Code:    "SECURITY_CHECKS_DISABLED",
                })
        }</span>

        // Validate blocked commands
        <span class="cov8" title="1">for i, command := range cfg.Security.BlockedCommands </span><span class="cov8" title="1">{
                if strings.TrimSpace(command) == "" </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationError{
                                Field:   fmt.Sprintf("security.blocked_commands[%d]", i),
                                Value:   command,
                                Message: "Empty blocked command pattern",
                                Code:    "EMPTY_BLOCKED_COMMAND",
                        })
                }</span>
        }

        <span class="cov8" title="1">return errors</span>
}

// PerformanceValidationRule validates performance configurations
type PerformanceValidationRule struct{}

func (r *PerformanceValidationRule) GetName() string <span class="cov0" title="0">{
        return "performance_validation"
}</span>

func (r *PerformanceValidationRule) GetSeverity() ValidationSeverity <span class="cov0" title="0">{
        return SeverityWarning
}</span>

func (r *PerformanceValidationRule) Validate(cfg *config.Config) []ValidationError <span class="cov8" title="1">{
        var errors []ValidationError

        if cfg.Performance == nil </span><span class="cov0" title="0">{
                return errors // Performance config is optional
        }</span>

        // Warn about potentially problematic settings
        <span class="cov8" title="1">if cfg.Performance.MaxConcurrentRequests &gt; 50 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "performance.max_concurrent_requests",
                        Value:   cfg.Performance.MaxConcurrentRequests,
                        Message: "Very high concurrent request limit may overwhelm LLM providers",
                        Code:    "HIGH_CONCURRENT_REQUESTS",
                })
        }</span>

        <span class="cov8" title="1">if cfg.Performance.RequestDelayMs &lt; 100 &amp;&amp; cfg.Performance.MaxConcurrentRequests &gt; 10 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationError{
                        Field:   "performance.request_delay_ms",
                        Value:   cfg.Performance.RequestDelayMs,
                        Message: "Low delay with high concurrency may trigger rate limiting",
                        Code:    "LOW_DELAY_HIGH_CONCURRENCY",
                })
        }</span>

        <span class="cov8" title="1">return errors</span>
}

// ModelCompatibilityValidationRule validates model and provider compatibility
type ModelCompatibilityValidationRule struct{}

func (r *ModelCompatibilityValidationRule) GetName() string <span class="cov0" title="0">{
        return "model_compatibility_validation"
}</span>

func (r *ModelCompatibilityValidationRule) GetSeverity() ValidationSeverity <span class="cov8" title="1">{
        return SeverityWarning
}</span>

func (r *ModelCompatibilityValidationRule) Validate(cfg *config.Config) []ValidationError <span class="cov8" title="1">{
        var errors []ValidationError

        if cfg.LLM == nil </span><span class="cov0" title="0">{
                return errors
        }</span>

        // Check for common model/provider mismatches
        <span class="cov8" title="1">modelProviderMap := map[string][]string{
                "gpt-3.5-turbo": {"openai"},
                "gpt-4":         {"openai"},
                "gemini-pro":    {"gemini", "google"},
                "claude-3":      {"anthropic"},
                "mixtral":       {"groq", "ollama"},
                "llama":         {"ollama", "groq"},
        }

        models := []string{
                cfg.LLM.EditingModel,
                cfg.LLM.SummaryModel,
                cfg.LLM.OrchestrationModel,
                cfg.LLM.WorkspaceModel,
        }

        for i, model := range models </span><span class="cov8" title="1">{
                if model == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">fieldNames := []string{
                        "llm.editing_model",
                        "llm.summary_model",
                        "llm.orchestration_model",
                        "llm.workspace_model",
                }

                // Check if model seems to be from a specific provider
                for modelPattern, validProviders := range modelProviderMap </span><span class="cov8" title="1">{
                        if strings.Contains(strings.ToLower(model), strings.ToLower(modelPattern)) </span><span class="cov8" title="1">{
                                // This looks like it should be used with specific providers
                                if len(validProviders) &gt; 0 </span><span class="cov8" title="1">{
                                        // For now, just add an info message
                                        errors = append(errors, ValidationError{
                                                Field:   fieldNames[i],
                                                Value:   model,
                                                Message: fmt.Sprintf("Model appears to be for providers: %s", strings.Join(validProviders, ", ")),
                                                Code:    "MODEL_PROVIDER_HINT",
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return errors</span>
}

// CreateStandardValidator creates a validator with standard rules
func CreateStandardValidator() *ConfigValidator <span class="cov8" title="1">{
        validator := NewConfigValidator()
        
        // Add standard validation rules
        validator.AddRule(&amp;LLMModelValidationRule{})
        validator.AddRule(&amp;SecurityValidationRule{})
        validator.AddRule(&amp;PerformanceValidationRule{})
        validator.AddRule(&amp;ModelCompatibilityValidationRule{})
        
        return validator
}</span>

// ValidatedLayeredConfigProvider wraps LayeredConfigProvider with validation
type ValidatedLayeredConfigProvider struct {
        *LayeredConfigProvider
        validator *ConfigValidator
}

// NewValidatedLayeredConfigProvider creates a new validated layered config provider
func NewValidatedLayeredConfigProvider(provider *LayeredConfigProvider) *ValidatedLayeredConfigProvider <span class="cov0" title="0">{
        return &amp;ValidatedLayeredConfigProvider{
                LayeredConfigProvider: provider,
                validator:             CreateStandardValidator(),
        }
}</span>

// GetProviderConfig validates configuration before returning
func (v *ValidatedLayeredConfigProvider) GetProviderConfig(providerName string) (*types.ProviderConfig, error) <span class="cov0" title="0">{
        // Validate the merged configuration first
        merged := v.loader.GetMergedConfig()
        result := v.validator.ValidateConfig(merged)
        
        if !result.IsValid() </span><span class="cov0" title="0">{
                // Log validation errors but don't fail completely
                fmt.Printf("Configuration validation errors: %d errors, %d warnings\n", 
                        len(result.Errors), len(result.Warnings))
                for _, err := range result.Errors </span><span class="cov0" title="0">{
                        fmt.Printf("  ERROR: %s\n", err.Error())
                }</span>
                <span class="cov0" title="0">for _, warn := range result.Warnings </span><span class="cov0" title="0">{
                        fmt.Printf("  WARNING: %s\n", warn.Error())
                }</span>
        }

        <span class="cov0" title="0">return v.LayeredConfigProvider.GetProviderConfig(providerName)</span>
}

// ValidateConfiguration validates the current configuration and returns results
func (v *ValidatedLayeredConfigProvider) ValidateConfiguration() *ValidationResult <span class="cov0" title="0">{
        merged := v.loader.GetMergedConfig()
        return v.validator.ValidateConfig(merged)
}</pre>
		
		<pre class="file" id="file3" style="display: none">package layered

import (
        "context"
        "fmt"
        "path/filepath"
        "sync"
        "time"

        "github.com/alantheprice/ledit/pkg/config"
)

// ConfigWatcher monitors configuration changes and triggers callbacks
type ConfigWatcher struct {
        mu        sync.RWMutex
        watchers  map[string]*FileWatcher
        callbacks []func(source string, newConfig *config.Config)
        stopCh    chan struct{}
        running   bool
}

// FileWatcher monitors a single file for changes
type FileWatcher struct {
        FilePath     string
        LastModTime  time.Time
        LastSize     int64
        CheckInterval time.Duration
        stopCh       chan struct{}
        callback     func()
}

// NewConfigWatcher creates a new configuration watcher
func NewConfigWatcher() *ConfigWatcher <span class="cov0" title="0">{
        return &amp;ConfigWatcher{
                watchers:  make(map[string]*FileWatcher),
                callbacks: []func(string, *config.Config){},
                stopCh:    make(chan struct{}),
                running:   false,
        }
}</span>

// AddFileWatch adds a file to watch for changes
func (cw *ConfigWatcher) AddFileWatch(filePath string, checkInterval time.Duration) error <span class="cov0" title="0">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        // Clean the path
        filePath = filepath.Clean(filePath)

        // Check if already watching
        if _, exists := cw.watchers[filePath]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("already watching file: %s", filePath)
        }</span>

        // Create file watcher
        <span class="cov0" title="0">watcher := &amp;FileWatcher{
                FilePath:      filePath,
                CheckInterval: checkInterval,
                stopCh:        make(chan struct{}),
                callback: func() </span><span class="cov0" title="0">{
                        cw.onFileChanged(filePath)
                }</span>,
        }

        // Initialize with current file state
        <span class="cov0" title="0">if err := watcher.updateFileState(); err != nil </span><span class="cov0" title="0">{
                // File might not exist yet, that's okay
                watcher.LastModTime = time.Time{}
                watcher.LastSize = 0
        }</span>

        <span class="cov0" title="0">cw.watchers[filePath] = watcher

        // Start watching if the main watcher is running
        if cw.running </span><span class="cov0" title="0">{
                go watcher.start()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RemoveFileWatch removes a file from watching
func (cw *ConfigWatcher) RemoveFileWatch(filePath string) <span class="cov0" title="0">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        filePath = filepath.Clean(filePath)
        if watcher, exists := cw.watchers[filePath]; exists </span><span class="cov0" title="0">{
                close(watcher.stopCh)
                delete(cw.watchers, filePath)
        }</span>
}

// AddCallback adds a callback to be called when configuration changes
func (cw *ConfigWatcher) AddCallback(callback func(source string, newConfig *config.Config)) <span class="cov0" title="0">{
        cw.mu.Lock()
        defer cw.mu.Unlock()
        cw.callbacks = append(cw.callbacks, callback)
}</span>

// Start starts the configuration watcher
func (cw *ConfigWatcher) Start(ctx context.Context) error <span class="cov0" title="0">{
        cw.mu.Lock()
        if cw.running </span><span class="cov0" title="0">{
                cw.mu.Unlock()
                return fmt.Errorf("config watcher is already running")
        }</span>

        <span class="cov0" title="0">cw.running = true
        
        // Start all file watchers
        for _, watcher := range cw.watchers </span><span class="cov0" title="0">{
                go watcher.start()
        }</span>
        <span class="cov0" title="0">cw.mu.Unlock()

        // Wait for context cancellation or stop signal
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return cw.Stop()</span>
        case &lt;-cw.stopCh:<span class="cov0" title="0">
                return nil</span>
        }
}

// Stop stops the configuration watcher
func (cw *ConfigWatcher) Stop() error <span class="cov0" title="0">{
        cw.mu.Lock()
        defer cw.mu.Unlock()

        if !cw.running </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Stop all file watchers
        <span class="cov0" title="0">for _, watcher := range cw.watchers </span><span class="cov0" title="0">{
                close(watcher.stopCh)
        }</span>

        <span class="cov0" title="0">close(cw.stopCh)
        cw.running = false
        return nil</span>
}

// onFileChanged is called when a watched file changes
func (cw *ConfigWatcher) onFileChanged(filePath string) <span class="cov0" title="0">{
        // Load the new configuration from the file
        source := &amp;FileConfigSource{
                FilePath: filePath,
                Name:     fmt.Sprintf("file:%s", filePath),
                Priority: 0, // Priority doesn't matter for change notifications
                Required: false,
        }

        ctx := context.Background()
        newConfig, err := source.Load(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error loading changed config file %s: %v\n", filePath, err)
                return
        }</span>

        // Notify all callbacks
        <span class="cov0" title="0">cw.mu.RLock()
        callbacks := make([]func(string, *config.Config), len(cw.callbacks))
        copy(callbacks, cw.callbacks)
        cw.mu.RUnlock()

        for _, callback := range callbacks </span><span class="cov0" title="0">{
                go callback(filePath, newConfig)
        }</span>
}

// updateFileState updates the file watcher's state with current file info
func (fw *FileWatcher) updateFileState() error <span class="cov0" title="0">{
        _, err := filepath.Abs(fw.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get file info using os.Stat equivalent
        // For now, use a simplified approach
        <span class="cov0" title="0">fw.LastModTime = time.Now()
        fw.LastSize = 0
        
        return nil</span>
}

// start starts the file watcher loop
func (fw *FileWatcher) start() <span class="cov0" title="0">{
        ticker := time.NewTicker(fw.CheckInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-fw.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if fw.checkForChanges() </span><span class="cov0" title="0">{
                                fw.callback()
                        }</span>
                }
        }
}

// checkForChanges checks if the file has changed since last check
func (fw *FileWatcher) checkForChanges() bool <span class="cov0" title="0">{
        // Simplified change detection - would use proper file stat in production
        // For now, assume files change periodically for demo purposes
        return false
}</span>

// WatchedLayeredConfigProvider extends LayeredConfigProvider with file watching
type WatchedLayeredConfigProvider struct {
        *ValidatedLayeredConfigProvider
        watcher *ConfigWatcher
}

// NewWatchedLayeredConfigProvider creates a new watched layered config provider
func NewWatchedLayeredConfigProvider(provider *ValidatedLayeredConfigProvider) *WatchedLayeredConfigProvider <span class="cov0" title="0">{
        watcher := NewConfigWatcher()
        
        watched := &amp;WatchedLayeredConfigProvider{
                ValidatedLayeredConfigProvider: provider,
                watcher:                        watcher,
        }

        // Add callback to reload configuration when files change
        watcher.AddCallback(func(source string, newConfig *config.Config) </span><span class="cov0" title="0">{
                fmt.Printf("Configuration changed in %s, reloading...\n", source)
                if err := provider.ReloadConfig(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error reloading configuration: %v\n", err)
                }</span>
        })

        <span class="cov0" title="0">return watched</span>
}

// WatchConfigFile adds a configuration file to be watched for changes
func (w *WatchedLayeredConfigProvider) WatchConfigFile(filePath string) error <span class="cov0" title="0">{
        return w.watcher.AddFileWatch(filePath, 2*time.Second) // Check every 2 seconds
}</span>

// StartWatching starts the configuration file watchers
func (w *WatchedLayeredConfigProvider) StartWatching(ctx context.Context) error <span class="cov0" title="0">{
        return w.watcher.Start(ctx)
}</span>

// StopWatching stops the configuration file watchers
func (w *WatchedLayeredConfigProvider) StopWatching() error <span class="cov0" title="0">{
        return w.watcher.Stop()
}</span>

// ConfigurationManager manages the complete configuration system with watching and validation
type ConfigurationManager struct {
        provider *WatchedLayeredConfigProvider
        ctx      context.Context
        cancel   context.CancelFunc
}

// NewConfigurationManager creates a new configuration manager
func NewConfigurationManager() (*ConfigurationManager, error) <span class="cov0" title="0">{
        factory := NewConfigurationFactory()
        layeredProvider, err := factory.CreateStandardSetup()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create layered provider: %w", err)
        }</span>

        <span class="cov0" title="0">validatedProvider := NewValidatedLayeredConfigProvider(layeredProvider)
        watchedProvider := NewWatchedLayeredConfigProvider(validatedProvider)

        ctx, cancel := context.WithCancel(context.Background())

        manager := &amp;ConfigurationManager{
                provider: watchedProvider,
                ctx:      ctx,
                cancel:   cancel,
        }

        return manager, nil</span>
}

// Start starts the configuration manager
func (cm *ConfigurationManager) Start() error <span class="cov0" title="0">{
        // Add standard config files to watch
        configFiles := []string{
                "~/.ledit/config.json",          // Global config
                "./.ledit/config.json",          // Project config
                "./config/development.json",      // Development config
                "./config/production.json",       // Production config
        }

        for _, file := range configFiles </span><span class="cov0" title="0">{
                if err := cm.provider.WatchConfigFile(file); err != nil </span><span class="cov0" title="0">{
                        // Non-fatal - file might not exist
                        fmt.Printf("Warning: Could not watch config file %s: %v\n", file, err)
                }</span>
        }

        // Start watching in background
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := cm.provider.StartWatching(cm.ctx); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Config watching stopped: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the configuration manager
func (cm *ConfigurationManager) Stop() error <span class="cov0" title="0">{
        cm.cancel()
        return cm.provider.StopWatching()
}</span>

// GetConfig returns the current merged and validated configuration
func (cm *ConfigurationManager) GetConfig() *config.Config <span class="cov0" title="0">{
        return cm.provider.loader.GetMergedConfig()
}</span>

// ValidateCurrentConfig validates the current configuration
func (cm *ConfigurationManager) ValidateCurrentConfig() *ValidationResult <span class="cov0" title="0">{
        return cm.provider.ValidateConfiguration()
}</span>

// GetProvider returns the underlying configuration provider
func (cm *ConfigurationManager) GetProvider() *WatchedLayeredConfigProvider <span class="cov0" title="0">{
        return cm.provider
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
